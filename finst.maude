fmod TERM-SUBST is
 pr META-LEVEL .

 sort TermSub .

 op mtTS : -> TermSub [ctor] .
 op _->_ : Term Term -> TermSub [ctor prec 30] .
 op _._ : TermSub TermSub -> TermSub [ctor comm assoc id: mtTS] .

 vars T T1 T2 : Term .
 var  TL : TermList .
 var  AtS : AttrSet .
 var  C : Condition .
 var  TS : TermSub .
 var  Ty : Type .
 var  Q : Qid .

 op _[_] : Term TermSub -> Term .
 eq T [ T -> T1 . TS] = T1 .
 eq T [TS] = sub(T, TS) [owise] .

 op sub : Term TermSub -> Term .
 eq sub(Q[TL], TS) = Q[sub*(TL, TS)] .
 eq sub(T, TS) = T [owise] .

 op sub* : TermList TermSub -> TermList .
 eq sub*(empty, TS) = empty .
 eq sub*((T, TL), TS) = T[TS], sub*(TL, TS) .

 op sub : Rule TermSub -> Rule .
 eq sub(rl T1 => T2 [AtS] ., TS) = rl T1[TS] => T2[TS] [AtS] . .
 eq sub(crl T1 => T2 if C [AtS] ., TS) = crl T1[TS] => T2[TS] if subCond(C, TS) [AtS] . .

 op subCond : Condition TermSub -> Condition .
 eq subCond(nil, TS) = nil .
 eq subCond(T1 = T2 /\ C, TS) = T1[TS] = T2[TS] /\ subCond(C, TS) .
 eq subCond(T1 := T2 /\ C, TS) = T1[TS] := T2[TS] /\ subCond(C, TS) .
 eq subCond(T1 => T2 /\ C, TS) = T1[TS] => T2[TS] /\ subCond(C, TS) .
 eq subCond(T : Ty /\ C, TS) = T[TS] : Ty /\ subCond(C, TS) .
endfm

fmod FINST is
 pr TERM-SUBST .
 pr CONVERSION .

 vars TL TL' TL'' : TermList .
 var  SSDS : SubsortDeclSet .
 vars T T' T'' T1 T2 : Term .
 vars C C' C'' : Constant .
 var  EqS : EquationSet .
 vars RS RS' : RuleSet .
 vars TS TS' : TermSub .
 vars S S1 S2 : String .
 var  COND : Condition .
 vars R R' R'' : Rule .
 var  ODS : OpDeclSet .
 var  IL : ImportList .
 var  MAS : MembAxSet .
 vars V V' : Variable .
 var  TyL : TypeList .
 var  AtS : AttrSet .
 var  SS : SortSet .
 var  M : Module .
 var  H : Header .
 vars Q Q' : Qid .
 vars N N' : Nat .
 var  Ty : Type .

 op finst : SModule -> SModule .
 ceq finst(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
              mod H is IL sorts SS . SSDS ODS MAS EqS RS' endm
  if RS' := finst(RS, ODS) .

 op finst : RuleSet OpDeclSet -> RuleSet .
 ceq finst(R R' RS, ODS) = finst(R'' RS, ODS)
  if R'' := join(R, R', ODS) .
 eq finst(RS, ODS) = RS [owise] .

 op join : Rule Rule OpDeclSet ~> Rule .
 ceq join(R, R', ODS) = simplify(sub(R, TS'))
  if TS := joinLeft(R, R', ODS) /\
     TS' := joinRight(sub(R, TS), sub(R', TS), ODS) /\
     (TS =/= mtTS) or (TS' =/= mtTS) .

 op joinLeft : Rule Rule OpDeclSet ~> TermSub .
 ceq joinLeft(R, R', ODS) = TS
  if T := getLHS(R) /\
     T' := getLHS(R') /\
     TS := join(T, T', ODS) .

 op joinRight : Rule Rule OpDeclSet ~> TermSub .
 ceq joinRight(R, R', ODS) = TS
  if T := getRHS(R) /\
     T' := getRHS(R') /\
     TS := backwards(T, T', ODS) .

 op backwards : Term Term OpDeclSet ~> TermSub .
 eq backwards('PD[T], 'PD[T'], ODS) = $backwards(T, T', ODS) .
 eq backwards(T, T', ODS) = $backwards(T, T', ODS) [owise] .

 op $backwards : Term Term OpDeclSet ~> TermSub .
 eq $backwards('__[TL], '__[TL'], ODS) = $backwards*(TL, TL', ODS) .
 eq $backwards('`{_|_`}[T, T'], '`{_|_`}[T, T''], ODS) =
             backwardsContents(T', T'', ODS) .

 op $backwards* : TermList TermList OpDeclSet ~> TermSub .
 eq $backwards*(empty, empty, ODS) = mtTS .
 eq $backwards*((T, TL), (T', TL'), ODS) = $join(T, T', ODS) .
                                      $join*(TL, TL', ODS) .

 op backwardsContents : Term Term OpDeclSet ~> TermSub .
 eq backwardsContents('__[TL], '__[TL'], ODS) = backwardsContents*(TL, TL', ODS) .
 eq backwardsContents('`[_-_`][T, T'], '`[_-_`][T, T1], ODS) = getEpitopes(ODS, T', T1) .
 eq backwardsContents(T, T', ODS) = mtTS [owise] .

 op getEpitopes : OpDeclSet Term Term ~> TermSub .
 eq getEpitopes(ODS, '__[TL], '__[TL']) = getEpitopes*(ODS, TL, TL') .
 eq getEpitopes(ODS, V, V') = mtTS .
 eq getEpitopes(ODS, C, C') = mtTS .
 eq getEpitopes(ODS, T, T') = sameEpitope(ODS, T, T') [owise] .

 op getEpitopes* : OpDeclSet TermList TermList ~> TermSub .
 eq getEpitopes*(ODS, empty, empty) = mtTS .
 eq getEpitopes*(ODS, (T, TL), (T', TL')) = getEpitopes(ODS, T, T') .
                                            getEpitopes*(ODS, TL, TL') .

 op sameEpitope : OpDeclSet Term Term ~> TermSub .
 ceq sameEpitope(op Q : TyL -> Ty [metadata(S) AtS] . ODS, Q'[TL], Q'[TL']) =
                                             (Q'[TL]) -> (Q'[C]) . (Q'[TL']) -> (Q'[C])
  if find(S, "epitopes", 0) =/= notFound /\
     S1 := getString(TL) /\
     find(S, S1, 0) =/= notFound /\
     S2 := getString(TL') /\
     find(S, S2, 0) =/= notFound /\
     C := qid(string(Q) + "." + string(Ty)) .

 op getString : Term ~> String .
 eq getString('__[TL]) = getString*(TL) .
 eq getString(C) = string(getName(C)) .
 ceq getString(T) = string(N, 10)
  if N := downTerm(T, 0) [owise] .

 op getString* : TermList ~> String .
 eq getString*((T, TL)) = getString(T) + getString*(TL) .
 eq getString*(empty) = "" .

 op backwardsContents* : TermList TermList OpDeclSet ~> TermSub .
 eq backwardsContents*(empty, empty, ODS) = mtTS .
 eq backwardsContents*((T, TL), (T', TL'), ODS) = backwardsContents(T, T', ODS) .
                                                  backwardsContents*(TL, TL', ODS) .

 op join : Term Term OpDeclSet ~> TermSub .
 eq join('PD[T], 'PD[T'], ODS) = $join(T, T', ODS) .
 eq join(T, T', ODS) = $join(T, T', ODS) [owise] .

 op $join : Term Term OpDeclSet ~> TermSub .
 eq $join('__[TL], '__[TL'], ODS) = $join*(TL, TL', ODS) .
 eq $join('`{_|_`}[T, T'], '`{_|_`}[T, T''], ODS) =
             joinLocContents(T', T'', ODS) .

 op $join* : TermList TermList OpDeclSet ~> TermSub .
 eq $join*(empty, empty, ODS) = mtTS .
 eq $join*((T, TL), (T', TL'), ODS) = $join(T, T', ODS) .
                                      $join*(TL, TL', ODS) .

 op joinLocContents : Term Term OpDeclSet ~> TermSub .
 eq joinLocContents('__[TL], '__[TL'], ODS) = joinLocContents*(TL, TL', ODS) .
 ceq joinLocContents('`[_-_`][T, T'], '`[_-_`][T1, T2], ODS) = T -> C . T1 -> C
  if T =/= T1 /\
     C := getFamily(ODS, T, T1) .
 eq joinLocContents(T, T', ODS) = mtTS [owise] .

 op joinLocContents* : TermList TermList OpDeclSet ~> TermSub .
 eq joinLocContents*(empty, empty, ODS) = mtTS .
 eq joinLocContents*((T, TL), (T', TL'), ODS) = joinLocContents(T, T', ODS) .
                                                joinLocContents*(TL, TL', ODS) .

 op getFamily : OpDeclSet Constant Constant ~> Constant .
 ceq getFamily(op Q : TyL -> Ty [metadata(S) AtS] . ODS, C, C') = C''
  if find(S, "type Family", 0) =/= notFound /\
     S1 := string(getName(C)) /\
     find(S, S1, 0) =/= notFound /\
     S2 := string(getName(C')) /\
     find(S, S2, 0) =/= notFound /\
     C'' := qid(string(Q) + "." + string(Ty)) .
 ceq getFamily(op Q : TyL -> Ty [metadata(S) AtS] . ODS , C, C') = C
  if find(S, "type Family", 0) =/= notFound /\
     Q == getName(C) /\
     S2 := string(getName(C')) /\
     find(S, S2, 0) =/= notFound .
 ceq getFamily(op Q : TyL -> Ty [metadata(S) AtS] . ODS , C, C') = C'
  if find(S, "type Family", 0) =/= notFound /\
     S1 := string(getName(C)) /\
     find(S, S1, 0) =/= notFound /\
     Q == getName(C') .

 op getLHS : Rule -> Term .
 eq getLHS(rl T => T' [AtS] .) = T .
 eq getLHS(crl T => T' if COND [AtS] .) = T .

 op getRHS : Rule -> Term .
 eq getRHS(rl T => T' [AtS] .) = T' .
 eq getRHS(crl T => T' if COND [AtS] .) = T' .

 op simplify : Rule -> Rule .
 eq simplify(rl T => T' [AtS] .) = rl simplify(T) => simplify(T') [AtS] . .
 eq simplify(crl T => T' if COND [AtS] .) = crl simplify(T) => simplify(T') if COND [AtS] . .

 op simplify : Term -> Term .
 eq simplify(C) = C .
 eq simplify(V) = V .
 eq simplify(Q[TL]) = Q[simplify*(remove(TL))] .

 op simplify* : TermList -> TermList .
 eq simplify*(empty) = empty .
 eq simplify*((T, TL)) = simplify(T), simplify*(TL) .

 op remove : TermList -> TermList .
 eq remove((TL, T, TL', T, TL'')) = remove((TL, T, TL', TL'')) .
 eq remove(TL) = TL [owise] .
endfm

